# capture-hic-pipeline/Snakefile
# -------------------------------------------------------------------
# Capture-HiC workflow: QC, interaction calling (Chicago/ChiCMaxima),
# .hic generation and insulation (FAN-C)
# Portable (conda), multi-sample, species-agnostic via config.yaml
# -------------------------------------------------------------------

import os
from pathlib import Path

# Default for real users; CI will override with --configfile config/config-ci.yaml
configfile: "config/config.yaml"

# Accept samples as dict {sample: {...}} or list [sample, ...]
def _resolve_samples(cfg):
    s = cfg.get("samples", {})
    if isinstance(s, dict):
        return list(s.keys())
    if isinstance(s, list):
        return s
    return []

# Helper to fetch per-sample metadata safely (works for dict or list configs)
def _sample_meta(sample_id):
    _s = config.get("samples", {})
    if isinstance(_s, dict):
        return _s.get(sample_id, {})
    return {}

SAMPLES = _resolve_samples(config)
OUTDIR  = config.get("outdir", "results")
THREADS = config.get("threads", {}).get("default", 4)

DESIGN = config.get("design", {})        # rmap, baitmap, probeinfo, dir
PARAMS = config.get("params", {})
TOOLS  = config.get("tools", {"rscript": "Rscript"})  # tool paths with safe default

## -------------------------------------------------------------------
# Default targets (precomputed to avoid wildcard inference issues)
# -------------------------------------------------------------------
TARGETS = []
for s in SAMPLES:
    TARGETS += [
        f"{OUTDIR}/{s}/{s}.hic",
        f"{OUTDIR}/{s}/{s}.insulation",
        f"logs/hicup/{s}.Rout",
        f"logs/capture_eff/{s}.Rout",
        f"logs/chicago/{s}.Rout",
        f"logs/chicmaxima/{s}.Rout",
    ]

rule all:
    input: TARGETS

# -------------------------------------------------------------------
# 1) HICUP QC (pure shell so conda is allowed)
# -------------------------------------------------------------------
rule hicup_qc:
    input:
        script    = "scripts/00_CaptureHiC_library_qualityControl.R",
        probeinfo = DESIGN.get("probeinfo", ""),
        rmap      = DESIGN.get("rmap", ""),
        baitmap   = DESIGN.get("baitmap", ""),
    output:
        hicup_cfg = temp(f"{OUTDIR}/{{{{sample}}}}/hicup_{{{{sample}}}}.config"),
        rout      = "logs/hicup/{sample}.Rout",
        bam       = f"{OUTDIR}/{{{{sample}}}}/mapped.bam",
        bed       = temp(f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.hicup.bed"),
        mat       = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.mat",
    params:
        outdir     = OUTDIR,
        # HICUP settings with safe defaults
        quiet      = lambda w: config.get('hicup', {}).get('quiet', 1),
        keep       = lambda w: config.get('hicup', {}).get('keep', 0),
        zip        = lambda w: config.get('hicup', {}).get('zip', 0),
        bowtie2    = lambda w: config.get('hicup', {}).get('bowtie2_bin', ''),
        index      = lambda w: config.get('hicup', {}).get('index', ''),
        digest     = lambda w: config.get('hicup', {}).get('digest', ''),
        fmt        = lambda w: config.get('hicup', {}).get('format', ''),
        longest    = lambda w: config.get('hicup', {}).get('longest', ''),
        shortest   = lambda w: config.get('hicup', {}).get('shortest', ''),
        # Per-sample fastqs (safe defaults for CI)
        r1         = lambda w: os.path.abspath(_sample_meta(w.sample).get('r1', 'R1.fastq.gz')),
        r2         = lambda w: os.path.abspath(_sample_meta(w.sample).get('r2', 'R2.fastq.gz')),
        # Tools
        hicup_bin  = TOOLS.get("hicup", "hicup"),
        bedtools   = TOOLS.get("bedtools", "bedtools"),
        perl       = TOOLS.get("perl", "perl"),
        bam2frags  = TOOLS.get("bam_to_fragments", "scripts/BamToFragments.pl"),
        rscript    = TOOLS.get("rscript", "Rscript"),
    threads: config.get("hicup", {}).get("threads", THREADS)
    conda:
        "envs/r.yaml"
    log:
        "logs/hicup/{sample}.log",
    shell:
        r"""
        mkdir -p logs/hicup {params.outdir}/{wildcards.sample}

        # Write per-sample HiCUP config
        cat > {output.hicup_cfg} <<CFG
# Auto-generated by Snakemake for {wildcards.sample}
Outdir:{params.outdir}/{wildcards.sample}
Threads:{threads}
Quiet:{params.quiet}
Keep:{params.keep}
Zip:{params.zip}
Bowtie2:{params.bowtie2}
Index:{params.index}
Digest:{params.digest}
Format:{params.fmt}
Longest:{params.longest}
Shortest:{params.shortest}
{params.r1}
{params.r2}
CFG

        # Run the R QC/mapping wrapper
        {params.rscript} "{input.script}" \
          --output "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --probeinfo "{input.probeinfo}" \
          --rmap "{input.rmap}" \
          --baitmap "{input.baitmap}" \
          --hicup_config "{output.hicup_cfg}" \
          --hicup_bin "{params.hicup_bin}" \
          --bedtools_bin "{params.bedtools}" \
          --perl_bin "{params.perl}" \
          --bam_to_fragments "{params.bam2frags}" \
          --mapped_bam "{output.bam}" \
          --bed_out "{output.bed}" \
          --mat_out "{output.mat}" \
          > {log} 2>&1

        echo "OK" > {output.rout}
        """

# -------------------------------------------------------------------
# 2) Capture efficiency control
# -------------------------------------------------------------------
rule capture_efficiency:
    input:
        script = "scripts/00_CaptureHiC_CaptureEfficiency_Control.R",
        mat    = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.mat",
        prev   = "logs/hicup/{sample}.Rout",
    output:
        rout  = "logs/capture_eff/{sample}.Rout",
        stats = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}_CaptureEfficiency.stat",
    params:
        outdir  = OUTDIR,
        rscript = TOOLS.get("rscript","Rscript"),
    threads: THREADS
    conda:
        "envs/r.yaml"
    log:
        "logs/capture_eff/{sample}.log",
    shell:
        r"""
        mkdir -p logs/capture_eff
        {params.rscript} "{input.script}" \
          --dir "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --mat "{input.mat}" \
          --stats "{output.stats}" \
          > {log} 2>&1
        echo "OK" > {output.rout}
        """

# -------------------------------------------------------------------
# 3) CHICAGO interaction calling
# -------------------------------------------------------------------
rule chicago:
    input:
        script  = "scripts/01_Prepare_Chicago.R",
        rmap    = DESIGN.get("rmap", ""),
        baitmap = DESIGN.get("baitmap", ""),
        bam     = f"{OUTDIR}/{{{{sample}}}}/mapped.bam",
        prev    = "logs/capture_eff/{sample}.Rout",
    params:
        outdir            = OUTDIR,
        design_dir        = DESIGN.get("dir", ""),
        bam2chicago       = TOOLS.get("chicago_bam2chicago", ""),
        make_design       = TOOLS.get("chicago_make_design", ""),
        python_bin        = TOOLS.get("python", "python"),
        force_make_design = config.get("chicago", {}).get("force_make_design", False),
        force_flag        = "TRUE" if config.get("chicago", {}).get("force_make_design", False) else "FALSE",
        rscript           = TOOLS.get("rscript","Rscript"),
    output:
        rout = "logs/chicago/{sample}.Rout",
        out  = f"{OUTDIR}/{{{{sample}}}}/chicago_interactions.tsv",
    threads: THREADS
    conda:
        "envs/chicago.yaml"
    log:
        "logs/chicago/{sample}.log",
    shell:
        r"""
        mkdir -p logs/chicago
        {params.rscript} "{input.script}" \
          --dir "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --rmap "{input.rmap}" \
          --baitmap "{input.baitmap}" \
          --bam "{input.bam}" \
          --design_dir "{params.design_dir}" \
          --out "{output.out}" \
          --bam2chicago "{params.bam2chicago}" \
          --make_design "{params.make_design}" \
          --python "{params.python_bin}" \
          --force_make_design {params.force_flag} \
          > {log} 2>&1
        echo "OK" > {output.rout}
        """

# -------------------------------------------------------------------
# 4) ChiCMaxima interaction calling
# -------------------------------------------------------------------
rule chicmaxima:
    input:
        script  = "scripts/02_ChiCMaxima.R",
        rmap    = DESIGN.get("rmap", ""),
        baitmap = DESIGN.get("baitmap", ""),
        prev    = "logs/chicago/{sample}.Rout",
    params:
        outdir     = OUTDIR,
        rscript    = TOOLS.get("rscript","Rscript"),
        perl       = TOOLS.get("perl","perl"),
        align2ibed = TOOLS.get("align2ibed","scripts/align2ibed.pl"),
    output:
        rout = "logs/chicmaxima/{sample}.Rout",
        ibed = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}_Cis.ibed",
    threads: THREADS
    conda:
        "envs/r.yaml"
    log:
        "logs/chicmaxima/{sample}.log",
    shell:
        r"""
        mkdir -p logs/chicmaxima
        {params.rscript} "{input.script}" \
          --dir "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --rmap "{input.rmap}" \
          --baitmap "{input.baitmap}" \
          --perl_bin "{params.perl}" \
          --align2ibed "{params.align2ibed}" \
          --ibed_out "{output.ibed}" \
          > {log} 2>&1
        echo "OK" > {output.rout}
        """

# -------------------------------------------------------------------
# 5) Generate .hic and optional TADs; then FAN-C insulation
# -------------------------------------------------------------------
rule hic_and_tads:
    input:
        script = "scripts/03_Generate_hic_and_TADs.R",
        rmap   = DESIGN.get("rmap", ""),
        mat    = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.mat",
        bam    = f"{OUTDIR}/{{{{sample}}}}/mapped.bam",  # keeps ordering
    params:
        outdir     = OUTDIR,
        java_bin   = TOOLS.get("java", "java"),
        juicer_jar = TOOLS.get("juicer_tools", ""),
        perl_bin   = TOOLS.get("perl", "perl"),
        bam2juicer = TOOLS.get("bam2juicer", ""),
        genome_id  = PARAMS.get("juicer_genome_id", ""),
        mem_gb     = PARAMS.get("juicer_mem_gb", 8),
        q_threshold= PARAMS.get("juicer_q", 1),
        rscript    = TOOLS.get("rscript","Rscript"),
    output:
        rout = "logs/hic/{sample}.Rout",
        hic  = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.hic",
    threads: THREADS
    conda:
        "envs/r.yaml"
    log:
        "logs/hic/{sample}.log",
    shell:
        r"""
        mkdir -p logs/hic {params.outdir}/{wildcards.sample}
        {params.rscript} "{input.script}" \
          --dir "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --mat "{input.mat}" \
          --rmap "{input.rmap}" \
          --pre "{params.outdir}/{wildcards.sample}/{wildcards.sample}_pre.txt" \
          --hic "{output.hic}" \
          --java "{params.java_bin}" \
          --juicer_tools "{params.juicer_jar}" \
          --perl "{params.perl_bin}" \
          --bam2juicer "{params.bam2juicer}" \
          --genome_id "{params.genome_id}" \
          --mem_gb {params.mem_gb} \
          --q {params.q_threshold} \
          > {log} 2>&1
        echo "OK" > {output.rout}
        """

rule insulation:
    input:
        script = "scripts/04_InsulationScore.R",
        hic    = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.hic",
        prev   = "logs/hic/{sample}.Rout",
    params:
        outdir      = OUTDIR,
        resolution  = PARAMS.get("fanc_resolution", "25kb"),
        balancing   = PARAMS.get("fanc_balancing", "ICE"),
        windows     = PARAMS.get("fanc_windows", []),  # list
        windows_str = " ".join(PARAMS.get("fanc_windows", [])) if isinstance(PARAMS.get("fanc_windows", []), (list, tuple)) else str(PARAMS.get("fanc_windows", "")),
        rscript     = TOOLS.get("rscript","Rscript"),
    output:
        rout = "logs/insulation/{sample}.Rout",
        ins  = f"{OUTDIR}/{{{{sample}}}}/{{{{sample}}}}.insulation",
    threads: THREADS
    conda:
        "envs/fanc.yaml"
    log:
        "logs/insulation/{sample}.log",
    shell:
        r"""
        mkdir -p logs/insulation
        {params.rscript} "{input.script}" \
          --dir "{params.outdir}/{wildcards.sample}" \
          --sample "{wildcards.sample}" \
          --hic "{input.hic}" \
          --out "{output.ins}" \
          --resolution "{params.resolution}" \
          --balancing "{params.balancing}" \
          --windows "{params.windows_str}" \
          > {log} 2>&1
        echo "OK" > {output.rout}
        """
